"use server";

import { db } from "@/lib/db/drizzle";
import {
  countryCode,
  geographicRegion,
  projectCompanyRole,
  projectContractType,
  projectDetails,
  projects,
  projectsCompanies,
  projectSector,
  projectsSectors,
  projectStage,
  projectStatus,
  projectsTechnologies,
  projectSubSector,
  projectTenderObjective,
  proposals,
  revenueModel,
  segment,
  technology,
} from "@/lib/db/schema";
import { and, count, eq, or, sql } from "drizzle-orm";
import type { ActionState, Pagination, ProjectFilters } from "@/lib/types";
import { parseLocation, validateDatabaseUUID } from "@/lib/utils";
import { getUserRole } from "./auth";
import { redirect } from "next/navigation";
import { DEFAULT_PAGE_SIZE } from "@/lib/constants";
import { createClient } from "@/lib/supabase/server";
import z from "zod";
import { revalidatePath } from "next/cache";

export async function getProjects(
  filters?: ProjectFilters,
  order?: Pagination,
  cursor?: { createdAt: Date; id: string },
  search = "",
  pageSize = 10,
) {
  let redirectPath: string | undefined;
  try {
    const userRole = await getUserRole();
    if (userRole === null || userRole === undefined) {
      console.log("User role not found, redirecting to login.");
      redirectPath = "/login";
    }
    const isGuestUser = userRole === "guest";

    // Base query for filtering
    const { region, sector, ...projectFilters } = filters || {};
    const whereFilters = { ...projectFilters, autoGenerated: false };
    let where =
      !isGuestUser &&
      whereFilters &&
      Object.values(whereFilters).filter((v) => v !== undefined).length
        ? and(
            ...Object.entries(whereFilters)
              .filter(([v]) => v !== undefined)
              .map(([k, v]) =>
                eq(projects[k as keyof typeof whereFilters], v as any),
              ),
          )
        : eq(projects.autoGenerated, false);

    if (search && !isGuestUser) {
      where = and(
        where,
        sql`to_tsvector('franglais', ${projects.name}) @@ plainto_tsquery('franglais', ${search})`,
      );
    }

    // Separate query for the total count based on filters
    const totalQuery = db
      .select({ count: count() })
      .from(projects)
      .where(where);

    // Main data fetching query
    const resultsQuery = db.query.projects.findMany({
      columns: {
        id: true,
        name: true,
        stage: true,
        plantCapacity: true,
        investmentCosts: true,
        createdAt: true,
      },
      extras: (projects, { sql }) => ({
        location: sql<string>`ST_AsText(${projects.location})`.as("location"),
      }),
      with: {
        country: {
          columns: {
            code: true,
            region: true,
          },
          // where: region ? (country) => eq(country.region, region) : undefined,
        },
        projectsSectors: {
          columns: { sector: true },
          // with: {
          //   sector: {
          //     columns: { id: true },
          //   },
          // },
          where:
            sector && !isGuestUser
              ? (projectsSectors) => eq(projectsSectors.sector, sector)
              : undefined,
        },
        projectsCompanies: {
          columns: { role: true },
          where: (projectsCompanies, { eq }) =>
            eq(projectsCompanies.role, "sponsor"),
          with: {
            company: {
              columns: {
                name: true,
              },
            },
          },
          limit: 1,
        },
        details: {
          columns: {
            operationalDate: true,
          },
        },
      },
      where: isGuestUser
        ? where
        : (projects, { or, gt, lt }) =>
            and(
              where,
              cursor?.createdAt
                ? or(
                    (order === "previous" ? gt : lt)(
                      projects.createdAt,
                      cursor.createdAt,
                    ),
                    and(
                      eq(projects.createdAt, cursor.createdAt),
                      (order === "previous" ? gt : lt)(projects.id, cursor.id),
                    ),
                  )
                : undefined,
            ),
      orderBy: (projects, { asc, desc }) =>
        order === "previous"
          ? [asc(projects.createdAt), asc(projects.id)]
          : [desc(projects.createdAt), desc(projects.id)],
      limit: isGuestUser ? DEFAULT_PAGE_SIZE : pageSize + 1,
    });

    const [results, totalResult] = await Promise.all([
      resultsQuery,
      totalQuery,
    ]);

    const hasMore = results.length > pageSize;
    if (hasMore) results.pop();

    if (order === "previous") results.reverse();

    const createCursor = ({ createdAt, id }: (typeof results)[number]) => ({
      createdAt,
      id,
    });

    const nextCursor =
      order !== "previous" && hasMore
        ? createCursor(results[results.length - 1])
        : order === "previous" && cursor
          ? cursor
          : undefined;
    const prevCursor =
      order === "previous" && hasMore
        ? createCursor(results[0])
        : order === "next" && cursor
          ? cursor
          : undefined;

    const projectsCount = totalResult[0]?.count ?? 0;
    if (!redirectPath) {
      return {
        projects: results.map(
          ({
            country,
            projectsSectors,
            projectsCompanies,
            details,
            location,
            ...project
          }) => {
            return {
              ...project,
              sponsor: projectsCompanies[0]?.company.name,
              country: country ? country.code : null,
              region: country?.region,
              date: details?.operationalDate,
              sectors: projectsSectors.map(({ sector }) => sector),
              location: parseLocation(location),
            };
          },
        ),
        total: isGuestUser
          ? Math.min(projectsCount, DEFAULT_PAGE_SIZE)
          : projectsCount,
        nextCursor: isGuestUser ? undefined : nextCursor,
        prevCursor: isGuestUser ? undefined : prevCursor,
      };
    }
  } catch (error) {
    console.error("Error fetching projects:", error);
    throw new Error("Failed to fetch projects");
  } finally {
    if (redirectPath) {
      redirect(redirectPath!);
    }
  }
}

export async function getProjectById(id: string) {
  try {
    const validId = validateDatabaseUUID(id, "Project ID");

    const result = await db.query.projects.findFirst({
      columns: { location: false },
      where: (projects, { eq }) => eq(projects.id, validId),
      extras: (projects, { sql }) => ({
        location: sql<string>`ST_AsText(${projects.location})`.as("location"),
      }),
      with: {
        country: {
          columns: {
            code: true,
            region: true,
          },
        },
        projectsSectors: {
          columns: {
            sector: true,
          },
        },
        projectsTechnologies: {
          columns: {
            technology: true,
          },
        },
        projectsCompanies: {
          columns: {
            role: true,
            percentageOwnership: true,
            equityAmount: true,
            details: true,
          },
          with: {
            company: {
              columns: {
                id: true,
                name: true,
              },
            },
          },
        },
        dealsAssets: {
          with: {
            deal: {
              columns: {
                id: true,
                update: true,
                date: true,
                type: true,
              },
            },
          },
        },
        details: true,
        proposal: true,
      },
    });

    if (!result) return null;

    // Destructure to separate nested objects and flatten the structure
    const {
      projectsSectors,
      projectsTechnologies,
      projectsCompanies,
      dealsAssets,
      details,
      proposal,
      ...projectCore
    } = result;

    console.log(result?.location);

    return {
      ...projectCore,
      // Combine details and proposal into the top-level object
      ...(details ?? {}),
      ...(proposal ?? {}),
      // Flatten related data into simple arrays
      sectors: projectsSectors.map((ps) => ps.sector),
      technologies: projectsTechnologies.map((pt) => pt.technology),
      companies: projectsCompanies.map(({ company, ...roleInfo }) => ({
        id: company.id,
        name: company.name,
        ...roleInfo,
      })),
      // Parse location string into coordinates
      location: parseLocation(result.location),
      deals: dealsAssets
        .map(({ deal }) => deal)
        .filter((deal) => deal.type === "project_update")
        .toSorted((a, b) => b.date.getTime() - a.date.getTime())
        .slice(0, 5), // Get only project updates, sorted by date desc, limit to 5
    };
  } catch (error) {
    console.error("Error fetching project by ID:", error);
    throw new Error("Failed to fetch project");
  }
}

export async function deleteProject(id: string): Promise<ActionState> {
  const supabase = createClient();

  // Authenticate user and check permissions
  const {
    data: { user },
  } = await (await supabase).auth.getUser();
  if (!user) {
    return { success: false, message: "Authentication failed." };
  }

  // Optional: Check if the user has an 'admin' or 'analyst_editor' role
  // This depends on your user role management setup
  const userRole = await getUserRole();
  if (userRole !== "admin") {
    return { success: false, message: "Permission denied." };
  }

  try {
    const deleted = await db
      .delete(projects)
      .where(eq(projects.id, id))
      .returning({ id: projects.id });

    if (deleted.length === 0) {
      return {
        success: false,
        message: `Project #${id} not found.`,
      };
    }

    return {
      success: true,
      message: `Successfully deleted Project #${id}.`,
    };
  } catch (error: any) {
    console.error(`Failed to delete Project #${id}:`, error);
    return { success: false, message: `Error: ${error.message}` };
  }
}

const emptyStringToUndefined = z.literal("").transform(() => undefined);

const zodToArray = <T>(enumValues: T[]) =>
  z.preprocess(
    (val) =>
      val === "" || val === null || val === undefined
        ? []
        : String(val).split(","),
    z.array(z.enum(enumValues as any[])).optional(),
  );

const zodStringJSON = (schema: z.ZodObject<Record<string, z.ZodType>>) =>
  z.preprocess(
    (val) => (typeof val === "string" ? JSON.parse(val) : val),
    schema.optional(),
  );

const zodToDate = z.iso
  .date()
  .or(emptyStringToUndefined)
  .optional()
  .pipe(z.transform((val) => (val ? new Date(val) : undefined)));

const zodBoolString = z
  .enum(["true", "on", "false", "off"])
  .optional()
  .transform((val) => val === "true" || val === "on");

const upsertProjectSchema = z
  .object({
    projectId: z.uuid().optional(),
    name: z.string().min(3, "Project name is required"),

    // Enums
    stage: z.enum(projectStage.enumValues).optional(),
    status: z.enum(projectStatus.enumValues).optional(),
    country: z.enum(countryCode.enumValues).optional(),

    // Enums
    sectors: zodToArray(projectSector.enumValues),
    technologies: zodToArray(technology.enumValues),
    subSectors: zodToArray(projectSubSector.enumValues),
    segments: zodToArray(segment.enumValues),

    // Location
    address: z.string().optional(),
    // Location is handled as string "lat,lng" and parsed server side
    location: z.string().optional(),

    // Numerics
    investmentCosts: z.coerce
      .number()
      .positive()
      .or(emptyStringToUndefined)
      .optional(),
    plantCapacity: z.coerce
      .number()
      .positive()
      .or(emptyStringToUndefined)
      .optional(),

    // Booleans (Checkboxes usually send "on" or nothing, need to handle)
    onOffGrid: zodBoolString,
    onOffShore: zodBoolString,
    colocatedStorage: zodBoolString,
    fundingSecured: zodBoolString,

    colocatedStorageCapacity: z.string().optional(),
    revenueModel: z.enum(revenueModel.enumValues).optional(),
    revenueModelDuration: z.coerce
      .number()
      .int()
      .positive()
      .or(emptyStringToUndefined)
      .optional(),
    contractType: zodToArray(projectContractType.enumValues),

    description: z.string().optional(),
    features: z.string().optional(),
    impacts: z.string().optional(),
    insights: z.string().optional(),
    milestone: z.string().optional(),

    // JSONB fields (Financing Strategy) - simplified to text map for now or specific fields
    financingStrategy: zodStringJSON(
      z.object({
        debt: z.coerce
          .number()
          .min(0)
          .max(100)
          .or(emptyStringToUndefined)
          .optional(),
        equity: z.coerce
          .number()
          .min(0)
          .max(100)
          .or(emptyStringToUndefined)
          .optional(),
        grants: z.coerce
          .number()
          .min(0)
          .max(100)
          .or(emptyStringToUndefined)
          .optional(),
      }),
    ).optional(),

    // Project Details
    transmissionInfrastructureDetails: z.string().optional(),
    ppaSigned: zodBoolString,
    eiaApproved: zodBoolString,
    gridConnectionApproved: zodBoolString,

    // Timeline - non-proposal
    financialClosingDate: zodToDate.optional(),
    constructionStart: zodToDate.optional(),
    operationalDate: zodToDate.optional(),
    endDate: zodToDate.optional(),

    // Proposal Specifics
    tenderObjective: z.enum(projectTenderObjective.enumValues).optional(),
    bidSubmissionDeadline: zodToDate.optional(),
    bidsReceived: z.coerce.number().int().or(emptyStringToUndefined).optional(),
    winningBid: z.coerce.number().or(emptyStringToUndefined).optional(),

    // Evaluation criteria (simple split)
    evaluationCriteria: zodStringJSON(
      z.object({
        technical: z.coerce
          .number()
          .min(0)
          .max(100)
          .or(emptyStringToUndefined)
          .optional(),
        financial: z.coerce
          .number()
          .min(0)
          .max(100)
          .or(emptyStringToUndefined)
          .optional(),
      }),
    ),

    // Relationships (Companies)
    companyId: z.array(z.uuid()).optional(),
    companyRole: z.array(z.enum(projectCompanyRole.enumValues)).optional(),
    companyPercentageOwnership: z
      .array(z.coerce.number().positive().max(100).or(emptyStringToUndefined))
      .optional(),
    companyEquityAmount: z
      .array(z.coerce.number().or(emptyStringToUndefined))
      .optional(),
    companyDetails: z.array(z.string()).optional(),
  })
  .superRefine((data, ctx) => {
    // Validate array lengths match
    const companyLength = data.companyId?.length ?? 0;
    if (data.companyRole && data.companyRole.length !== companyLength) {
      ctx.addIssue({
        code: "custom",
        message: "Companies count mismatch",
        path: ["companyRole"],
      });
    }
  });

export async function upsertProject(
  prevState: ActionState | undefined,
  formData: FormData,
): Promise<ActionState> {
  try {
    // 1. Reconstruct data from FormData for validation
    const rawData = {
      ...Object.fromEntries(formData.entries()),
      companyId: formData.getAll("companyId"),
      companyRole: formData.getAll("companyRole"),
      companyPercentageOwnership: formData.getAll("companyPercentageOwnership"),
      companyEquityAmount: formData.getAll("companyEquityAmount"),
      companyDetails: formData.getAll("companyDetails"),
    };

    const validatedData = upsertProjectSchema.safeParse(rawData);

    if (!validatedData.success) {
      console.error(
        "Validation errors:",
        validatedData.error.flatten().fieldErrors,
      );
      return {
        success: false,
        message: "Invalid form data",
        errors: validatedData.error.flatten().fieldErrors,
      };
    }

    const { data } = validatedData;
    const isEditMode = !!data.projectId;
    const isProposal = data.stage === "proposal";

    const location =
      (data.location?.split(",").map(parseFloat) as [number, number]) ||
      undefined;

    const [result] = await db.transaction(async (tx) => {
      let projectId = data.projectId;

      const projectData = {
        name: data.name,
        stage: data.stage,
        status: data.status ?? null,
        country: data.country ?? null,
        address: data.address ?? null,
        location,
        description: data.description ?? null,
        subSectors: data.subSectors ?? [],
        plantCapacity: data.plantCapacity ?? null,
        investmentCosts: data.investmentCosts ?? null,
        onOffGrid: data.onOffGrid ?? null,
        onOffShore: data.onOffShore ?? null,
        segments: data.segments ?? [],
        revenueModel: data.revenueModel ?? null,
        revenueModelDuration: data.revenueModelDuration ?? null,
        colocatedStorage: data.colocatedStorage ?? null,
        colocatedStorageCapacity: data.colocatedStorageCapacity ?? null,
        contractType: data.contractType ?? [],
        milestone: data.milestone ?? null,
        fundingSecured: data.fundingSecured ?? null,
        financingStrategy: data.financingStrategy ?? null,
        impacts: data.impacts ?? null,
        insights: data.insights ?? null,
        features: data.features ?? null,
      };

      if (isEditMode) {
        const [updatedProject] = await tx
          .update(projects)
          .set(projectData)
          .where(eq(projects.id, data.projectId!))
          .returning({ id: projects.id });
        if (!updatedProject) throw new Error("Project not found for update.");
        projectId = updatedProject.id;
      } else {
        const [newProject] = await tx
          .insert(projects)
          .values(projectData)
          .returning({ id: projects.id });
        projectId = newProject.id;
      }

      if (isEditMode) {
        await tx
          .delete(projectsSectors)
          .where(eq(projectsSectors.projectId, projectId));
        await tx
          .delete(projectsTechnologies)
          .where(eq(projectsTechnologies.projectId, projectId));
        await tx
          .delete(projectsCompanies)
          .where(eq(projectsCompanies.projectId, projectId));
        await tx
          .delete(projectDetails)
          .where(eq(projectDetails.projectId, projectId));
        await tx.delete(proposals).where(eq(proposals.projectId, projectId));
      }

      if (data.sectors && data.sectors.length > 0) {
        const sectorsToInsert = data.sectors.map((sector) => ({
          projectId,
          sector,
        }));
        await tx.insert(projectsSectors).values(sectorsToInsert);
      }
      if (data.technologies && data.technologies.length > 0) {
        await tx.insert(projectsTechnologies).values(
          data.technologies.map((technology) => ({
            projectId,
            technology,
          })),
        );
      }
      if (data.companyId && data.companyId.length > 0) {
        const companiesToInsert = data.companyId
          .map((id, i) => ({
            projectId,
            companyId: id,
            role: data.companyRole?.[i]!,
            percentageOwnership: data.companyPercentageOwnership?.[i] ?? null,
            equityAmount: data.companyEquityAmount?.[i] ?? null,
            details: data.companyDetails?.[i] || null,
          }))
          .filter((c) => c.role !== undefined);

        if (companiesToInsert.length > 0) {
          await tx.insert(projectsCompanies).values(companiesToInsert);
        }
      }

      if (isProposal) {
        const proposalValues = {
          projectId,
          tenderObjective: data.tenderObjective ?? null,
          bidSubmissionDeadline: data.bidSubmissionDeadline ?? null,
          evaluationCriteria: data.evaluationCriteria ?? null,
          bidsReceived: data.bidsReceived ?? null,
          winningBid: data.winningBid ?? null,
        };
        // Insert/update proposal details
        await tx.insert(proposals).values(proposalValues).onConflictDoUpdate({
          target: proposals.projectId,
          set: proposalValues,
        });
      } else {
        const detailValues = {
          projectId,
          transmissionInfrastructureDetails:
            data.transmissionInfrastructureDetails ?? null,
          ppaSigned: data.ppaSigned ?? null,
          financialClosingDate: data.financialClosingDate ?? null,
          eiaApproved: data.eiaApproved ?? null,
          gridConnectionApproved: data.gridConnectionApproved ?? null,
          constructionStart: data.constructionStart ?? null,
          endDate: data.endDate ?? null,
          operationalDate: data.operationalDate ?? null,
        };
        // Insert/update project details
        await tx
          .insert(projectDetails)
          .values(detailValues)
          .onConflictDoUpdate({
            target: projectDetails.projectId,
            set: detailValues,
          });
      }

      return [{ id: projectId }];
    });

    revalidatePath("/admin/projects");

    return {
      success: true,
      message: `Successfully ${isEditMode ? "updated" : "created"} project.`,
    };
  } catch (error: any) {
    console.error("Failed to upsert project:", error);
    return {
      success: false,
      message: error.message || "An unexpected database error occurred.",
    };
  }
}
