DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user;
-- inserts a row into public.users
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin
  insert into public.users (id, email, name, profile_picture_url)
  values (
    new.id, 
    new.email, 
    COALESCE(
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'name', 
      CONCAT(new.raw_user_meta_data ->> 'first_name', ' ', new.raw_user_meta_data ->> 'last_name')
    ),
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$;
-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- -- Custom types
-- create type public.app_permission as enum ('channels.delete', 'messages.delete');

-- -- ROLE PERMISSIONS
-- create table public.role_permissions (
--   id           bigint generated by default as identity primary key,
--   role         user_role not null,
--   permission   app_permission not null,
--   unique (role, permission)
-- );
-- comment on table public.role_permissions is 'Application permissions for each role.';

-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.user_role;
  begin
    -- Fetch the user role in the users table
    select role into user_role from public.users where id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.users
to supabase_auth_admin;

revoke all
  on table public.users
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.users
as permissive for select
to supabase_auth_admin
using (true);

-- create or replace function public.authorize(
--   requested_permission app_permission
-- )
-- returns boolean as $$
-- declare
--   bind_permissions int;
--   user_role public.user_role;
-- begin
--   -- Fetch user role once and store it to reduce number of calls
--   select (auth.jwt() ->> 'user_role')::public.user_role into user_role;

--   select count(*)
--   into bind_permissions
--   from public.role_permissions
--   where role_permissions.permission = requested_permission
--     and role_permissions.role = user_role;

--   return bind_permissions > 0;
-- end;
-- $$ language plpgsql stable security definer set search_path = '';